use clap::{Parser, Subcommand};
use reqwest::blocking::Client;
use reqwest::header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_TYPE};
use serde_json::{json, Value};
use std::{env, io};

#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Generate tests for the passed in code
    Tests { code: Option<String> },
    /// Generate docstrings for the passed in code.
    Docs { code: Option<String> },
}

/// Validates the provided code or prompts for input if none is given.
///
/// This function takes an `Option<String>` containing a code. If the code is `Some`, it converts 
/// the inner `String` to a `String` type and returns it. If the code is `None`, the function 
/// prompts the user to input a code via the standard input. If the user does not provide any input, 
/// the function panics with an error message.
///
/// # Arguments
///
/// * `code` - An `Option<String>` which may contain a code or may be `None`.
///
/// # Returns
///
/// * `String` - The validated code either from the input argument or from stdin.
///
/// # Panics
///
/// * If the code is `None` and no input is provided via stdin.
/// * If there is an error reading from stdin.
fn validate_code(code: &Option<String>) -> String {
    match code {
        Some(i) => i.to_string(),
        None => {
            let mut buffer = String::new();
            let stdin = io::stdin();
            match stdin.read_line(&mut buffer) {
                Ok(_) => {
                    if buffer.is_empty() {
                        panic!(
                            "No code provided. Must provide an input via an arg or through stdin."
                        )
                    }
                }
                Err(_) => panic!("Error reading from stdin."),
            }
            buffer
        }
    }
}


/// Sends a request to the OpenAI API with system and user prompts, and returns the generated response.
///
/// # Arguments
///
/// * `system_prompt` - A string slice representing the system's prompt or instructions.
/// * `user_prompt` - A string slice representing the user's input or query.
/// * `client` - A reference to an HTTP client used to send the request.
///
/// # Returns
///
/// A `String` containing the content of the response generated by the OpenAI API.
///
/// # Panics
///
/// This function will panic if the HTTP request fails or if the response cannot be deserialized correctly.
fn call_open_ai<'a>(system_prompt: &'a str, user_prompt: &'a str, client: &Client) -> String {
    let req_json = json!({
        "model": "gpt-4o",
        "messages": [
            {
                "role": "system",
                "content": String::from(system_prompt)
            },
            {
                "role": "user",
                "content": user_prompt
            }
        ]
    });

    let response = client
        .post("https://api.openai.com/v1/chat/completions")
        .json(&req_json)
        .send();

    // Eventually make a response object to deserialize into.
    let result: Value = serde_json::from_str(&response.unwrap().text().unwrap()).unwrap();

    result["choices"][0]["message"]["content"].as_str().unwrap().to_string()
}

/// Main entry point of the program. This function handles command-line arguments parsing,
/// environment variable retrieval, and executes the appropriate commands based on user input.
///
/// - For the `Tests` command, it validates user-provided code, identifies its programming language,
///   and generates test functions for the code.
/// - For the `Docs` command, it validates user-provided code and generates a docstring for it.
///
/// # Panics
/// Panics if the `OPENAI_API_KEY` environment variable is not set or contains invalid characters.
///
/// # Arguments
/// * None
///
/// # Commands
/// * `Tests { code }`: Generates test functions for the provided code.
/// * `Docs { code }`: Generates a docstring for the provided code.
fn main() {
    let cli = Cli::parse();
    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY env var is not set.").to_string();
    let client_builder = Client::builder();
    let mut headers = HeaderMap::new();
    let auth_string = format!("Bearer {openai_api_key}");

    headers.insert(CONTENT_TYPE, HeaderValue::from_static("application/json"));
    headers.insert(
        AUTHORIZATION,
        auth_string
            .try_into()
            .expect("Invalid Chars in bearer token."),
    );

    let client = client_builder.default_headers(headers).build();

    match &cli.command {
        Commands::Tests { code } => {
            let user_code = validate_code(code);
            let code_language = call_open_ai(
                "You are an AI Assistant specialized in identifying what language code is written in. Respond with only the coding language the text supplied is written in. If you do not know respond with: NA",
                &user_code, 
                client.as_ref().unwrap()
            );
            let test_code = call_open_ai(
                "You are an AI assistant that generates tests for code provided by the user in their speicified language. Return the code as text and nothing else. Do not use Markdown.",
                &format!("Generate test functions in {code_language} for the following code: {user_code}"),
                client.as_ref().unwrap()
            );
            println!("{}", test_code);
        }
        Commands::Docs { code } => {
            let user_code = validate_code(code);
            let code_language = call_open_ai(
                "You are an AI Assistant specialized in identifying what language code is written in. Respond with only the coding language the text supplied is written in. If you do not know respond with: NA",
                &user_code, 
                client.as_ref().unwrap()
            );
            let doc_string= call_open_ai(
                "You are an AI Assistant specialized in writing docstrings for code. Provide a docstring for the users code in plain text and nothing else. Do not use return Markdown.",
                &format!("Generate doc strings for the following code that has been written in {code_language}: {user_code}"), 
                client.as_ref().unwrap()
            );
            println!("{}", doc_string);
            
        }
    }
}
